// Copyright (c) 2009, 2023 Jonathan Engdahl
// BSD license -- see the accompanying README.txt

// This file contains definitions related to the underlying implementation of OpenMP.
// Applications that *use* OpenMP should not need this file.

#ifndef LIBGOMP_H
#define LIBGOMP_H

#include "context.hpp"
#include "LinkedList.hpp"

#define GOMP_STACK_SIZE 3072

#define GOMP_MAX_NUM_THREADS 5
#define GOMP_NUM_TEAMS 4
#define GOMP_NUM_TASKS 16

#define OMP_NUM_THREADS 4

extern void libgomp_init();
extern void libgomp_reinit();

extern "C" int gomp_get_thread_id();


extern int omp_verbose;
#define OMP_VERBOSE_DEFAULT 0

// the code that constitutes a task
typedef void TASKFN(void *);


// a task is defined by code and data
struct task
    {
    TASKFN *fn;             // the thread function generated by OMP
    char *data;             // the thread's local data pointer
    task *next;             // pointer to the next task in a list
    };

// an omp_thread
struct omp_thread
    {
    // the thread's context
    Context context;        // the thread's registers

    int id = 0;             // a unique ID for each thread, also the index into the thread table
    int team_id = 0;        // the number of a thread within the team
    const char *name = 0;   // optional thread name, for debug

    struct task *task = 0;  // the thread's implicit task, nonzero if running

    omp_thread *team = 0;   // pointer to the master thread of the team this thread is a member of
    omp_thread *next = 0;   // link to the next team member

    unsigned single = 0;    // used to detect the first thread to arrive at a "single"
    bool arrived = false;   // arrived at a barrier, waiting for other threads to arrive
    bool mwaiting = false;  // waiting on a mutex
    bool twaiting = false;   // indicates when a thread is waiting for a task. Not affected by wait for event, etc.

    // stuff pertaining to this thread as a team master
    int team_count = 0;
    LinkedList<omp_thread, &omp_thread::next> members;    // list of the other members of the team this thread is the master of, which are linked by their "next" pointer.
    bool mutex = false;
    unsigned tsingle = 0;    // used to detect the first thread to arrive at a "single"
    int sections_count = 0;
    int sections = 0;
    int section = 0;
    int task_count = 0;
    LinkedList<struct task, &task::next> task_list;  // list of explicit tasks for this team
    void *copyprivate = 0;

    // debug data
    char *stack_low;        // low address of the stack (for debug)
    char *stack_high;       // high address of the stack pointer
    };

extern omp_thread omp_threads[GOMP_MAX_NUM_THREADS];

extern "C"
inline omp_thread *omp_this_thread()
    {
    omp_thread *thread;

    __asm__ __volatile__("    mov %[thread], r9" : [thread]"=r"(thread));

    return thread;
    }


extern "C"
inline omp_thread *omp_this_team()
    {
    omp_thread &thread = *omp_this_thread();
    omp_thread *team = thread.team_id == 0 ? &thread : thread.team;
    return team;
    }

template<unsigned N>
void libgomp_start_thread(omp_thread &thread, THREADFN *code, char (&stack)[N], uintptr_t arg = 0)
    {
    thread.stack_low = &stack[0];
    thread.stack_high = &stack[N];
    thread.context.spawn(code, stack, arg);
    }

// called by background to poll all the threads and resume them if they have something to do
extern void gomp_poll_threads();


#endif // LIBGOMP_H
