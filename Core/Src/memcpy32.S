// memcpy32

// Works like memcpy, except the source and destination are assumed to be 4-byte aligned,
// and the size is a multiple of four bytes. It is assumed that the source and destination
// are non-overlapping.

// It uses LDM and STM so that AXI bursts of up to 32 bytes are generated by the CPU.
// It avoids the use of r9 (the dedicated thread register).

// This code is optimized for speed and should only be used in well-controlled and tested
// environments.

// This code only works correctly if the arguments are all multiples of four.
// Since it would fail badly if the size was not a multiple of four, an AND instruction is
// included to round it down just in case.

// This was generated by ChatGPT-4o, then optimized

	.cpu cortex-m7
	.arch armv7e-m
	.syntax unified
	.thumb
	.file	"memcpy32.S"
    .section .text
    .global memcpy32

memcpy32:
    // R0 = dest, R1 = src, R2 = size

    // Save registers that will be used
    push {r4-r8, r10-r11, lr}

    // Ensure size is a multiple of 4
    and r2, #-4

    // If given size is less than or equal to 32 bytes, handle the entire transfer as a "remainder".
    subs r2, #32
    ble remainder_copy

    // Arrive here if there are more than 32 bytes to copy

    // The main loop copies 32-byte blocks until there are 32 bytes or less remaining
main_loop:
    ldmia r1!, {r3-r8,r10-r11}  // Load 8 words from source
    stmia r0!, {r3-r8,r10-r11}  // Store 8 words to destination
    subs r2, #32                // Subtract the next 32 bytes
    bgt main_loop

    // Note that when arriving at this point, the size register contains the
    // number of bytes remaining MINUS 32, thus it is a negative number.
    // Following the computed jump is a table of code chunks. Each chunk is exactly
    // 16 bytes long. This is enforced by padding with NOPs.
    // The following code jumps to the address of the last chunk plus (remaining_bytes - 32) * 16.
    // Thus if there are 32 bytes remaining, it jumps to copy_32. If there are zero bytes remaining
    // it jumps to copy_0.

remainder_copy:
    adr r3, copy_32             // Get address of the last chunk
    add r3, r3, r2, lsl #2      // Calculate address of the required chunk
    orr r3, #1					// set the Thumb bit
    bx r3                       // Branch to the calculated address

// Each of these code chunks copies a block of memory, generating a single read and
// a single write burst transaction of up to 32 bytes for each block.
// Each code chunk must be exactly 16 bytes long. The code is padded with NOPs
// to ensure this.

// At the end of each chunk, the saved registers are reloaded and the subroutine returns.

copy_0:
    pop {r4-r8, r10-r11, pc}
    nop
    nop
    nop    
    nop    
    nop    
    nop    

copy_4:
    ldr r3, [r1], #4
    str r3, [r0], #4
    pop {r4-r8, r10-r11, pc}
    nop    
    nop    

copy_8:
    ldmia r1!, {r3-r4}
    stmia r0!, {r3-r4}
    pop {r4-r8, r10-r11, pc}
    nop    
    nop    
    nop    
    nop    

copy_12:
    ldmia r1!, {r3-r5}
    stmia r0!, {r3-r5}
    pop {r4-r8, r10-r11, pc}
    nop    
    nop    
    nop    
    nop    

copy_16:
    ldmia r1!, {r3-r6}
    stmia r0!, {r3-r6}
    pop {r4-r8, r10-r11, pc}
    nop    
    nop    
    nop    
    nop    

copy_20:
    ldmia r1!, {r3-r7}
    stmia r0!, {r3-r7}
    pop {r4-r8, r10-r11, pc}
    nop    
    nop    
    nop    
    nop    

copy_24:
    ldmia r1!, {r3-r8}
    stmia r0!, {r3-r8}
    pop {r4-r8, r10-r11, pc}
    nop    
    nop    

copy_28:
    ldmia r1!, {r3-r8, r10}
    stmia r0!, {r3-r8, r10}
    pop {r4-r8, r10-r11, pc}
    nop    
    nop    

copy_32:
    ldmia r1!, {r3-r8, r10-r11}
    stmia r0!, {r3-r8, r10-r11}
    pop {r4-r8, r10-r11, pc}

